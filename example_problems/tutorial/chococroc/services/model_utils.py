#!/usr/bin/env python3
"""This file contains the useful functions to handle modelling problem."""
import subprocess, os

from bot_interface import service_server_requires_and_gets_file_of_handle


# CONSTANTS:
TMP_DIR = '../tmp97815'
MOD_FILENAME = 'model.mod'
DAT_FILENAME = 'instance.dat'
OUT_FILENAME = 'output.txt'


def get_path_of(filename):
    current_dir = os.path.abspath(os.path.dirname(__file__))
    TMP_DIR_PATH = os.path.join(current_dir, TMP_DIR)
    if filename == 'tmp_dir':
        return TMP_DIR_PATH
    elif filename == 'mod':
        return os.path.join(TMP_DIR_PATH, MOD_FILENAME)
    elif filename == 'dat':
        return os.path.join(TMP_DIR_PATH, DAT_FILENAME)
    elif filename == 'out':
        return os.path.join(TMP_DIR_PATH, OUT_FILENAME)
    else:
        raise RuntimeError('in get_path_of() wrong filename')


def initTMP_DIR():
    """Creates a folder where to store the temporary files needed by the service. Our goal is that this should work whether the service is run in local or on a server."""
    tmp_dir_path = get_path_of('tmp_dir')
    if not os.path.exists(tmp_dir_path):
        os.makedirs(tmp_dir_path)


def receive_modelling_files(TAc, LANG):
    """Enables the receipt of hte files sent by the bot and return the inputs"""
    # Initialize TMP_DIR
    initTMP_DIR()

    # get files
    TAc.print(LANG.render_feedback("start", f"# Hey, I am ready to start and get your input files (mod={MOD_FILENAME} dat={DAT_FILENAME} input=input.txt)."), "yellow")
    mod = service_server_requires_and_gets_file_of_handle('mod').decode()
    dat = service_server_requires_and_gets_file_of_handle('dat').decode()
    input = service_server_requires_and_gets_file_of_handle('input').decode()

    # create in TMP_DIR mod file
    try:
        with open(get_path_of('mod'), 'w') as mod_file:
            mod_file.write(mod)
    except os.error as e:
        raise RuntimeError('write-error', MOD_FILENAME, e)

    # create in TMP_DIR dat file
    try:
        with open(get_path_of('dat'), 'w') as dat_file:
            dat_file.write(dat)
    except os.error as e:
        raise RuntimeError('write-error', DAT_FILENAME, e)
    
    # return input
    return input


def run_GPLSOL():
    """launches glpsol on the .mod and .dat files contained in TMP_DIR. The output of glpsol is displayed on standard output. If with_output_file=True then the procedure expects a file 'output.txt' to be generated by glpsol in TMP_DIR and its format to comply sol_style. If not, the procedure warns the user and terminates the service. If 'output.txt' is valid then the solution is returned."""
    # RUN gplsol
    try:
        subprocess.run([
            "glpsol", 
            "-m", get_path_of('mod'), 
            "-d", get_path_of('dat')
        ], cwd=get_path_of('tmp_dir'), timeout=30.0)        
    except subprocess.TimeoutExpired:
        raise RuntimeError('process-timeout')
    except subprocess.CalledProcessError as e: 
        raise RuntimeError('process-call')
    except Exception as e:
        raise RuntimeError('process-exception')


# TODO: fix PermissionError:
def cleanTMP_DIR():
    """Remove TMP_DIR"""
    os.remove(get_path_of('tmp_dir'))
